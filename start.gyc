# 1 "start.S"
# 1 "/home/gyc/Development/imx/uboot-imx/cpu/arm_cortexa8//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "start.S"
# 33 "start.S"
# 1 "/home/gyc/Development/imx/uboot-imx/include/config.h" 1

# 1 "/home/gyc/Development/imx/uboot-imx/include/configs/mx6q_arm2.h" 1
# 25 "/home/gyc/Development/imx/uboot-imx/include/configs/mx6q_arm2.h"
# 1 "/home/gyc/Development/imx/uboot-imx/include/asm/arch/mx6.h" 1
# 26 "/home/gyc/Development/imx/uboot-imx/include/configs/mx6q_arm2.h" 2
# 81 "/home/gyc/Development/imx/uboot-imx/include/configs/mx6q_arm2.h"
# 1 "/home/gyc/Development/imx/uboot-imx/include/config_cmd_default.h" 1
# 82 "/home/gyc/Development/imx/uboot-imx/include/configs/mx6q_arm2.h" 2
# 3 "/home/gyc/Development/imx/uboot-imx/include/config.h" 2
# 1 "/home/gyc/Development/imx/uboot-imx/include/asm/config.h" 1
# 3 "/home/gyc/Development/imx/uboot-imx/include/config.h" 2
# 34 "start.S" 2
# 1 "/home/gyc/Development/imx/uboot-imx/include/version.h" 1
# 28 "/home/gyc/Development/imx/uboot-imx/include/version.h"
# 1 "/home/gyc/Development/imx/uboot-imx/include/version_autogenerated.h" 1
# 29 "/home/gyc/Development/imx/uboot-imx/include/version.h" 2
# 35 "start.S" 2

.globl _start
_start: b reset
 ldr pc, _undefined_instruction
 ldr pc, _software_interrupt
 ldr pc, _prefetch_abort
 ldr pc, _data_abort
 ldr pc, _not_used
 ldr pc, _irq
 ldr pc, _fiq

_undefined_instruction: .word undefined_instruction
_software_interrupt: .word software_interrupt
_prefetch_abort: .word prefetch_abort
_data_abort: .word data_abort
_not_used: .word not_used
_irq: .word irq
_fiq: .word fiq
_pad: .word 0x12345678
.global _end_vect
_end_vect:

 .balignl 16,0xdeadbeef
# 69 "start.S"
_TEXT_BASE:
 .word 0x27800000

.globl _armboot_start
_armboot_start:
 .word _start




.globl _bss_start
_bss_start:
 .word __bss_start

.globl _bss_end
_bss_end:
 .word _end
# 103 "start.S"
reset:



 mrs r0, cpsr
 bic r0, r0, #0x1f
 orr r0, r0, #0xd3
 msr cpsr,r0
# 137 "start.S"
 bl cpu_init_crit
# 160 "start.S"
stack_setup:
 ldr r0, _TEXT_BASE @ upper 128 KiB: relocated uboot
 sub r0, r0, #(2 * 1024 * 1024) @ malloc area
 sub r0, r0, #128 @ bdinfo



 sub sp, r0, #12 @ leave 3 words for abort-stack
 and sp, sp, #~7 @ 8 byte alinged for (ldr/str)d


clear_bss:
 ldr r0, _bss_start @ find start of bss segment
 ldr r1, _bss_end @ stop here
 mov r2, #0x00000000 @ clear value
clbss_l:
 str r2, [r0] @ clear BSS location
 cmp r0, r1 @ are we at the end yet
 add r0, r0, #4 @ increment clear index pointer
 bne clbss_l @ keep clearing till at end




 ldr pc, _start_armboot @ jump to C code

_start_armboot: .word start_armboot
# 197 "start.S"
cpu_init_crit:



 mov r0, #0 @ set up for MCR
 mcr p15, 0, r0, c8, c7, 0 @ invalidate TLBs
 mcr p15, 0, r0, c7, c5, 0 @ invalidate icache




 mrc p15, 0, r0, c1, c0, 0
 bic r0, r0, #0x00002000 @ clear bits 13 (--V-)
 bic r0, r0, #0x00000007 @ clear bits 2:0 (-CAM)
 orr r0, r0, #0x00000002 @ set bit 1 (--A-) Align
 orr r0, r0, #0x00000800 @ set bit 12 (Z---) BTB
 mcr p15, 0, r0, c1, c0, 0







 mov ip, lr @ persevere link reg across call
 bl lowlevel_init @ go setup pll,mux,memory
 mov lr, ip @ restore link
 mov pc, lr @ back to my caller







@
@ IRQ stack frame.
@
# 265 "start.S"
 .macro bad_save_user_regs
 sub sp, sp, #72 @ carve out a frame on current
      @ user stack
 stmia sp, {r0 - r12} @ Save user registers (now in
      @ svc mode) r0-r12

 ldr r2, _armboot_start
 sub r2, r2, #((2 * 1024 * 1024))
 sub r2, r2, #(128 + 8) @ set base 2 words into abort
      @ stack
 ldmia r2, {r2 - r3} @ get values for "aborted" pc
      @ and cpsr (into parm regs)
 add r0, sp, #72 @ grab pointer to old stack

 add r5, sp, #52
 mov r1, lr
 stmia r5, {r0 - r3} @ save sp_SVC, lr_SVC, pc, cpsr
 mov r0, sp @ save current stack into r0
      @ (param register)
 .endm

 .macro irq_save_user_regs
 sub sp, sp, #72
 stmia sp, {r0 - r12} @ Calling r0-r12
 add r8, sp, #60 @ !! R8 NEEDS to be saved !!
      @ a reserved stack spot would
      @ be good.
 stmdb r8, {sp, lr}^ @ Calling SP, LR
 str lr, [r8, #0] @ Save calling PC
 mrs r6, spsr
 str r6, [r8, #4] @ Save CPSR
 str r0, [r8, #8] @ Save OLD_R0
 mov r0, sp
 .endm

 .macro irq_restore_user_regs
 ldmia sp, {r0 - lr}^ @ Calling r0 - lr
 mov r0, r0
 ldr lr, [sp, #60] @ Get PC
 add sp, sp, #72
 subs pc, lr, #4 @ return & move spsr_svc into
      @ cpsr
 .endm

 .macro get_bad_stack
 ldr r13, _armboot_start @ setup our mode stack (enter
      @ in banked mode)
 sub r13, r13, #((2 * 1024 * 1024)) @ move past malloc pool
 sub r13, r13, #(128 + 8) @ move to reserved a couple
      @ spots for abort stack

 str lr, [r13] @ save caller lr in position 0
      @ of saved stack
 mrs lr, spsr @ get the spsr
 str lr, [r13, #4] @ save spsr in position 1 of
      @ saved stack

 mov r13, #0x13 @ prepare SVC-Mode
 @ msr spsr_c, r13
 msr spsr, r13 @ switch modes, make sure
      @ moves will execute
 mov lr, pc @ capture return pc
 movs pc, lr @ jump to next instruction &
      @ switch modes.
 .endm

 .macro get_bad_stack_swi
 sub r13, r13, #4 @ space on current stack for
      @ scratch reg.
 str r0, [r13] @ save R0's value.
 ldr r0, _armboot_start @ get data regions start
 sub r0, r0, #((2 * 1024 * 1024)) @ move past malloc pool
 sub r0, r0, #(128 + 8) @ move past gbl and a couple
      @ spots for abort stack
 str lr, [r0] @ save caller lr in position 0
      @ of saved stack
 mrs r0, spsr @ get the spsr
 str lr, [r0, #4] @ save spsr in position 1 of
      @ saved stack
 ldr r0, [r13] @ restore r0
 add r13, r13, #4 @ pop stack entry
 .endm

 .macro get_irq_stack @ setup IRQ stack
 ldr sp, IRQ_STACK_START
 .endm

 .macro get_fiq_stack @ setup FIQ stack
 ldr sp, FIQ_STACK_START
 .endm




 .align 5
undefined_instruction:
 get_bad_stack
 bad_save_user_regs
 bl do_undefined_instruction

 .align 5
software_interrupt:
 get_bad_stack_swi
 bad_save_user_regs
 bl do_software_interrupt

 .align 5
prefetch_abort:
 get_bad_stack
 bad_save_user_regs
 bl do_prefetch_abort

 .align 5
data_abort:
 get_bad_stack
 bad_save_user_regs
 bl do_data_abort

 .align 5
not_used:
 get_bad_stack
 bad_save_user_regs
 bl do_not_used
# 408 "start.S"
 .align 5
irq:
 get_bad_stack
 bad_save_user_regs
 bl do_irq

 .align 5
fiq:
 get_bad_stack
 bad_save_user_regs
 bl do_fiq
# 431 "start.S"
 .align 5
.global v7_flush_dcache_all
v7_flush_dcache_all:
 stmfd r13!, {r0 - r5, r7, r9 - r12, r14}

 mov r7, r0 @ take a backup of device type
 cmp r0, #0x3 @ check if the device type is
      @ GP
 moveq r12, #0x1 @ set up to invalide L2
smi: .word 0x01600070 @ Call SMI monitor (smieq)
 cmp r7, #0x3 @ compare again in case its
      @ lost
 beq finished_inval @ if GP device, inval done
      @ above

 mrc p15, 1, r0, c0, c0, 1 @ read clidr
 ands r3, r0, #0x7000000 @ extract loc from clidr
 mov r3, r3, lsr #23 @ left align loc bit field
 beq finished_inval @ if loc is 0, then no need to
      @ clean
 mov r10, #0 @ start clean at cache level 0
inval_loop1:
 add r2, r10, r10, lsr #1 @ work out 3x current cache
      @ level
 mov r1, r0, lsr r2 @ extract cache type bits from
      @ clidr
 and r1, r1, #7 @ mask of the bits for current
      @ cache only
 cmp r1, #2 @ see what cache we have at
      @ this level
 blt skip_inval @ skip if no cache, or just
      @ i-cache
 mcr p15, 2, r10, c0, c0, 0 @ select current cache level
      @ in cssr
 mov r2, #0 @ operand for mcr SBZ
 mcr p15, 0, r2, c7, c5, 4 @ flush prefetch buffer to
      @ sych the new cssr&csidr,
      @ with armv7 this is 'isb',
      @ but we compile with armv5
 mrc p15, 1, r1, c0, c0, 0 @ read the new csidr
 and r2, r1, #7 @ extract the length of the
      @ cache lines
 add r2, r2, #4 @ add 4 (line length offset)
 ldr r4, =0x3ff
 ands r4, r4, r1, lsr #3 @ find maximum number on the
      @ way size
 clz r5, r4 @ find bit position of way
      @ size increment
 ldr r7, =0x7fff
 ands r7, r7, r1, lsr #13 @ extract max number of the
      @ index size
inval_loop2:
 mov r9, r4 @ create working copy of max
      @ way size
inval_loop3:
 orr r11, r10, r9, lsl r5 @ factor way and cache number
      @ into r11
 orr r11, r11, r7, lsl r2 @ factor index number into r11
 mcr p15, 0, r11, c7, c6, 2 @ invalidate by set/way
 subs r9, r9, #1 @ decrement the way
 bge inval_loop3
 subs r7, r7, #1 @ decrement the index
 bge inval_loop2
skip_inval:
 add r10, r10, #2 @ increment cache number
 cmp r3, r10
 bgt inval_loop1
finished_inval:
 mov r10, #0 @ swith back to cache level 0
 mcr p15, 2, r10, c0, c0, 0 @ select current cache level
      @ in cssr
 mcr p15, 0, r10, c7, c5, 4 @ flush prefetch buffer,
      @ with armv7 this is 'isb',
      @ but we compile with armv5

 ldmfd r13!, {r0 - r5, r7, r9 - r12, pc}
